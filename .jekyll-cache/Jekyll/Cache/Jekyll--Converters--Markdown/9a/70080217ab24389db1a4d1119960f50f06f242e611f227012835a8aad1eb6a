I"ò<h2 id="explicaci√≥n-te√≥rica">Explicaci√≥n te√≥rica</h2>
<p>Hoy voy a compartir algo que me ha parecido interesante para poder contar alguna vez en clase como t√©cnica de hacking y con lo que me he topado en la m√°quina <a href="https://tryhackme.com/room/internal">Internal</a> de THM</p>

<p>No vamos a partir de 0, sino de una supuesta situaci√≥n donde ya hemos llevado a cabo un trabajo previo como una exhaustiva enumeraci√≥n, compromiso de una m√°quina y enumeraci√≥n de nuevo.</p>

<p>Supongamos que hemos comprometido una m√°quina de tal forma que tenemos acceso mediante SSH. Hemos comprobado que tenemos una interfaz con la IP <code class="language-plaintext highlighter-rouge">172.17.0.1</code>, lo cu√°l ya nos da una pista de algo que confirmaremos m√°s adelante.</p>

<p><img src="../img/hydra/ip-a.png" alt="" /></p>

<p>Adem√°s, en el proceso de enumeraci√≥n hemos descubierto que en la IP <code class="language-plaintext highlighter-rouge">172.17.0.2</code> tenemos un puerto 8080 a la escucha.</p>

<h2 id="caso-pr√°ctico">Caso pr√°ctico</h2>
<p>El problema es que desde la interfaz de nuestra VPN <code class="language-plaintext highlighter-rouge">10.9.0.0/16</code> s√≥lo tenemos acceso al segmento de red de las m√°quinas de THM <code class="language-plaintext highlighter-rouge">10.10.0.0/16</code> pero no al segmento <code class="language-plaintext highlighter-rouge">172.17.0.0/16</code>.</p>

<p>Una posible soluci√≥n a esta situaci√≥n es realizar una redirecci√≥n de puertos o t√∫nel SSH hacia la segunda m√°quina aprovech√°ndonos de nuestro acceso SSH a la primera y que ambas comparten interfaz. De esta forma desde nuestra m√°quina atacante podremos tener acceso a la segunda m√°quina, en principio inaccesible, haciendo uso del acceso SSH a la primera de ellas.</p>

<p>La <a href="https://www.tecmint.com/create-ssh-tunneling-port-forwarding-in-linux/">manera</a> de hacer esto ser√≠a:</p>

<p><img src="../img/hydra/tunelSSH.png" alt="" /></p>

<p>Con esto conseguimos que accediendo al puerto <code class="language-plaintext highlighter-rouge">9001</code> de nuestra m√°quina local y, utilizando la conexi√≥n SSH de la m√°quina <code class="language-plaintext highlighter-rouge">internal.thm</code>, en realidad accedamos al puerto <code class="language-plaintext highlighter-rouge">8080</code> de la m√°quina remota.</p>

<p>De la enumeraci√≥n previa ya habr√≠amos llegado a la conclusi√≥n de que deb√≠a ser un servicio web, as√≠ que probamos a acceder con el navegador para comprobar que la redirecci√≥n es correcta:</p>

<p><img src="../img/hydra/jenkinsweb.png" alt="" /></p>

<p>Resulta ser un panel de login de Jenkins.</p>

<p>Si hacemos una b√∫squeda r√°pida de las credenciales por defecto de Jenkins, vemos que el usuario por defecto es <code class="language-plaintext highlighter-rouge">admin</code> y la contrase√±a la que tenga configurada. As√≠ pues, podemos proceder a un ataque de fuerza bruta contra este formulario de login.</p>

<p>Este login va por una petici√≥n <code class="language-plaintext highlighter-rouge">POST</code> y debemos ver como se forma para poder lanzar el ataque adecuado al formato de <a href="https://github.com/vanhauser-thc/thc-hydra">Hydra</a>. Para ver la petici√≥n, podemos utilizar o bien Burp Suite o simplemente las herramientas de desarrollador del navegador:</p>

<p><img src="../img/hydra/post1.png" alt="" /></p>

<p><img src="../img/hydra/post2.png" alt="" /></p>

<p>Y por tanto, llevamos a cabo el ataque especificado con el siguiente comando completo (el formato de Hydra podemos consultarlo en su ayuda):</p>

<p><img src="../img/hydra/hydra.png" alt="" /></p>

<p>Una vez obtenidas las credenciales, podemos obtener una reverse shell en la nueva m√°quina siguiendo el procedimiento que nos explican en el siempre √∫til libro de 
<a href="https://book.hacktricks.xyz/pentesting/pentesting-web/jenkins#execute-groovy-script">Hacktricks</a>.</p>

<p>Primero ajustamos el <em>payload</em> en Base64 para el caso de nuestra IP y nuestro puerto:</p>

<p><img src="../img/hydra/cyberchef.png" alt="" /></p>

<p>Y luego lo empleamos en el procedimiento que hemos visto en Hacktricks:</p>

<p><img src="../img/hydra/shell_jenkins.png" alt="" /></p>

<p><img src="../img/hydra/shell_jenkins2.png" alt="" /></p>

<p>Una vez obtenida la reverse shell, confirmamos algo casi obvio, atendiendo a dos motivos:</p>

<ol>
  <li>En la fase de enumeraci√≥n habremos visto que Docker est√° instalado en la primera m√°quina que atacamos</li>
  <li>La red <code class="language-plaintext highlighter-rouge">172.17.0.0/16</code> es propia de Docker</li>
</ol>

<p>Adem√°s, si se nos ocurre atender a la salida de un <code class="language-plaintext highlighter-rouge">netstat</code> en la primera m√°quina, veremos que el puerto <code class="language-plaintext highlighter-rouge">8080</code> est√° expuesto para la m√°quina local, haciendo sospechar que est√° publicado para llegar al contenedor Docker en el mismo puerto:</p>

<p><img src="../img/hydra/net.png" alt="" /></p>

<p>No obstante, comprob√©moslo:</p>

<p><img src="../img/hydra/shell_jenkins3.png" alt="" /></p>

<p>Y corroboramos que, efectivamente, estamos dentro de un contenedor Docker.</p>

<p>Esto lo habremos consultado <a href="https://stackoverflow.com/questions/20010199/how-to-determine-if-a-process-runs-inside-lxc-docker">aqu√≠</a> ya que ni de lejos somos los primeros en preguntarnos como averig√ºar si estamos trabajando dentro de un contenedor.</p>

<p>As√≠ pues, tendr√≠amos que continuar intentado t√©cnicas para escapar del contenedor o enumerar el propio contenedor para continuar buscando nuestra flag de root. Esto ya escapa a la intenci√≥n del post que pretend√≠a hacer notar el mecanismo para la redirecci√≥n de puertos.</p>

:ET